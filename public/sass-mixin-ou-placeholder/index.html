<!DOCTYPE html>
<html>
<head>
	<title>Sejedev - "Seje" dev, nÃ£o seja sobrinho!</title>
	<meta charset="utf-8">
  	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

	<link rel="stylesheet" type="text/css" href="http://localhost/jhonny-roger/public/css/style.min.css?1500245850">
	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<script>
	  (adsbygoogle = window.adsbygoogle || []).push({
	    google_ad_client: "ca-pub-9403183739906461",
	    enable_page_level_ads: true
	  });
	</script>
</head>
<body>
	<header id="sd-header">
		<a href="http://localhost/jhonny-roger/public/" id="sd-logo">Sejedev</a>
		<nav id="sd-nav-menu">
			<ul>
				<li><a href="http://localhost/jhonny-roger/public/categories/nodejs">Artigos</a></li>
				<li><a href="http://localhost/jhonny-roger/public/categories/jquery">Noticias</a></li>
				<li><a href="http://localhost/jhonny-roger/public/categories/jquery">Projetos</a></li>
				<li><a href="http://localhost/jhonny-roger/public/categories/jquery">Colabore</a></li>
			</ul>
		</nav>
		<form action="#" id="sd-search-form">
			<input type="search" name="search" placeholder="FaÃ§a a sua busca!">
		</form>
	</header>
<section id="sd-main-post">
    
    <h1>
        <a href="/jhonny-roger/public/frontend-week/">
            Front-end Week
        </a>
    </h1>
    <p class="sd-main-excerpt">
         Uma overdose de eventos e palestras sobre front-end em uma semana. 
    </p>
    <p class="sd-main-author">
        por <a href="/jhonny-roger/public/author/diego-eis">Diego Eis"</a>27/06/2017
    </p>
    
</section>



<div class="tb-post">

  <section class="tb-post-content">
    <article class="tb-post-article">
      

<p>Se Ã© um tema que sempre vejo a respeito da utilizaÃ§Ã£o ou nÃ£o, Ã© sobre o uso de prÃ© processadores CSS. Alguns <em>devs</em> que costumo seguir e ler os artigos, e que pra mim sÃ£o algumas das nossas referÃªncias, apontam as suas consideraÃ§Ãµes sobre o tema. O Miller Medeiros, em um <a href="http://blog.millermedeiros.com/the-problem-with-css-pre-processors/">post</a> mostra alguns pontos negativos na utilizaÃ§Ã£o de prÃ© processadores. O Jean Carlos Emer em um outro <a href="http://tableless.com.br/css-steroids/" title="CSS on steroids">post</a> mostra as reais vantagens de se utilizar um prÃ©-processador. O Diego Eis, em um outro <a href="http://tableless.com.br/pre-processadores-usar-ou-nao-usar/" title="PrÃ© processadores: usar ou nÃ£o usar?">post</a> faz uma conclusÃ£o muito boa sobre a utilizaÃ§Ã£o ou nÃ£o:</p>

<blockquote>
<p>PrÃ© processadores podem ajudar como tambÃ©m podem maltratar bastante. Basta um escorregÃ£o para que seu projeto vire um inferno. &#8211; Diego Eis</p>
</blockquote>

<p>A utilizaÃ§Ã£o ou nÃ£o de um prÃ© processador fica a seu critÃ©rio mas, se vocÃª jÃ¡ utiliza nos seus projetos ou estÃ¡ pensando em usar, vocÃª sabe o que sÃ£o um <strong>placeholder</strong> e um <strong>mixin</strong>? Se sim, sabe qual a principal diferenÃ§a entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um <a href="http://www.sitepoint.com/sass-mixin-placeholder/">artigo</a> do <a href="https://twitter.com/HugoGiraudel" title="Perfil do twitter do desenvolvedor Hugo Giraudel">Hugo Giraudel</a>, um dev front-end francÃªs, no <a href="http://www.sitepoint.com/" title="Link do website SitePoint">SitePoint</a> que trata exatamente sobre esse assunto.</p>

<p>â€”</p>

<p>Quando comecei a trabalhar com SASS cerca de um ano e meio atrÃ¡s, uma coisa que me levou tempo para entender foi a diferenÃ§a entre <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins">incluir um mixin</a></em> e <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders">estender um placeholder</a></em>. Na verdade, atÃ© mesmo a noÃ§Ã£o de <em>placeholder</em> era uma espÃ©cie de magia negra vodu naquela Ã©poca.</p>

<p>Se vocÃª estiver em uma situaÃ§Ã£o semelhante, nÃ£o se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um <em>mixin</em>, e quando usar um <em>placeholder do SASS</em>. VocÃª vai entender que ambos tem diferentes finalidades e nÃ£o devem ser confundidas.</p>

<p><em>Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro prÃ©-processador CSS, seja Stylus, LESS, ou outro que vocÃª venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteÃºdo deste artigo para a ferramenta de sua escolha</em>.</p>

<p>Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos <strong>placeholder e mixins do SASS</strong>, entÃ£o vamos fazer isso jÃ¡.</p>

<h2 id="entendendo-o-mixin">Entendendo o mixin</h2>

<p>Um mixin Ã© uma diretiva que permite que vocÃª defina vÃ¡rias regras com diversos argumentos. Pense nisso como uma funÃ§Ã£o que irÃ¡ retornar conteÃºdo CSS ao invÃ©s de um valor. Aqui estÃ¡ a definiÃ§Ã£o de <em>mixin</em> da <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">referÃªncia do SASS</a>:</p>

<blockquote cite="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">
  <p>
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes nÃ£o semÃ¢nticas como <i>.float-left</i>. Mixins podem tambÃ©m conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem atÃ© mesmo possuÃ­rem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  </p>
</blockquote>

<p>Agora que cobrimos a terminologia, vamos dizer que vocÃª encontra algumas declaraÃ§Ãµes que sÃ£o repetidas vÃ¡rias vezes ao longo da sua folha de estilos. VocÃª que estÃ¡ familiarizado com o conceito de DRY (<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">Don&#8217;t Repeat Yourself</a>), sabe que a repetiÃ§Ã£o de cÃ³digo Ã© ruim. Para corrigir isso, vocÃª pode escrever um mixin para todas aquelas declaraÃ§Ãµes repetidas:</p>

<pre class="lang-scss">@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
</pre>

<p><em>Nota: Se vocÃª nÃ£o passar um argumento para um mixin, vocÃª pode omitir os parÃªnteses. Na verdade, vocÃª pode atÃ© omiti-los na definiÃ§Ã£o do <code>@mixin</code></em>.</p>

<p>Com este mixin recÃ©m-criado, vocÃª nÃ£o precisa repetir aquelas trÃªs linhas de cÃ³digo cada vez que precisar centralizar um elemento; vocÃª simplesmente inclui o mixin. Muito prÃ¡tico, nÃ£o Ã©?!</p>

<p>Algumas vezes vocÃª vai querer um mixin para construir o que vocÃª chamaria de <em>shorthand</em> para algumas propriedades. Por exemplo, largura e altura. VocÃª nÃ£o estÃ¡ cansado de escrever as duas linhas vÃ¡rias e vÃ¡rias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!</p>

<pre class="lang-scss">@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
</pre>

<p>Muito simples, nÃ£o Ã©? Note como deixamos o parÃ¢metro <code>$height</code> ser opcional e, por padrÃ£o assumir o mesmo valor do parÃ¢metro <code>$width</code> na assinatura do mixin. Agora, sempre que vocÃª precisar definir as dimensÃµes para um elemento, vocÃª pode simplesmente fazer isso:</p>

<pre class="lang-scss">.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
</pre>

<p><em>Nota: Um outro bom exemplo de mixin seria <a href="http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/">este aqui</a> que eu fiz para evitar de escrever as posiÃ§Ãµes <code>top</code>, <code>left</code>, <code>right</code> e <code>bottom</code> toda vez que quiser utilizar um sistema de posicionamento diferente do estÃ¡tico.</em></p>

<h2 id="conhecendo-seu-placeholder">Conhecendo seu Placeholder</h2>

<p>Placeholders sÃ£o um tipo de coisa estranha. Eles sÃ£o classes que nÃ£o sÃ£o retornadas quando o seu SCSS Ã© compilado. VocÃª deve entÃ£o pensar: <em>&#8220;Qual Ã© o sentido disso?&#8221;</em>. Na verdade, o ponto seria minÃ­mo senÃ£o fosse a expressÃ£o <code>@extend</code>. Mas vamos por partes. Essa Ã© a forma que vocÃª escreve um placeholder:</p>

<pre class="lang-scss">%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
</pre>

<p><em>Nota do editor: Como um placeholder, um mixin Ã© igualmente inÃºtil, a menos que seja referenciado, assim essa seÃ§Ã£o nÃ£o estÃ¡ dizendo que eles sÃ£o diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareÃ§a similar com um bloco de declaraÃ§Ã£o CSS, nÃ£o serÃ¡ gerado por conta prÃ³pria.</em></p>

<p>Basicamente vocÃª escreve exatamente como uma classe <code>CSS</code> exceto pelo sÃ­mbolo % ao invÃ©s do ponto. AlÃ©m disso, segue as mesmas <a href="http://www.w3.org/TR/html401/types.html#type-cdata">regras de nomenclatura</a> das classes.</p>

<p>Agora, se vocÃª tentar compilar seu SCSS, vocÃª nÃ£o vai ver esse pedaÃ§o de cÃ³digo no arquivo gerado. Como eu disse: <strong>placeholders nÃ£o sÃ£o compilados</strong>.</p>

<p>EntÃ£o, por agora, esse placeholder Ã© totalmente inÃºtil. VocÃª nÃ£o consegue fazer qualquer uso dele a nÃ£o ser que vocÃª veja o <code>@extend</code>. Um <code>@extend</code> tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usÃ¡-lo:</p>

<pre class="lang-scss">.container {
  @extend %center;
}
</pre>

<p>Ao fazer isso, o arquivo SASS vai pegar o conteÃºdo do placeholder <code>%center</code> e aplicÃ¡-lo no <code>.container</code> (mesmo que isso nÃ£o aconteÃ§a exatamente assim &#8211; mas isso nÃ£o Ã© importante agora). Como eu disse, vocÃª tambÃ©m pode <em>estender</em> seletores CSS jÃ¡ existentes (alÃ©m de placeholders SCSS) dessa maneira:</p>

<pre class="lang-scss">.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
</pre>

<p>Esse Ã© um caso muito comum para o uso do <code>@extend</code>. Nesse caso, pedimos para a classe <code>.table-zebra</code> se comportar exatamente como a classe <code>.table</code> e entÃ£o adicionamos as regras especÃ­ficas da classe <code>.table-zebra</code>. <em>Estender</em> seletores Ã© bastante conveniente quando vocÃª desenvolve seu site ou aplicaÃ§Ã£o em componentes modulares.</p>

<h2 id="qual-utilizar">Qual utilizar?</h2>

<p>EntÃ£o, a pergunta permanece: o que vocÃª deve usar? Bem, como tudo em nossa Ã¡rea: <strong>depende</strong>. Depende do contexto e, em uma outra anÃ¡lise, do que vocÃª estÃ¡ querendo fazer.</p>

<p>O melhor conselho seria: se vocÃª precisa de variÃ¡veis, utilize o mixin. Caso contrÃ¡rio, use o placeholder. HÃ¡ duas razÃµes para isso:</p>

<ul>
<li>Primeiro, vocÃª nÃ£o pode usar variÃ¡veis em um placeholder. Na verdade, atÃ© pode, mas vocÃª nÃ£o consegue <em>passar</em> uma variÃ¡vel em um placeholder para gerar um conteÃºdo especÃ­fico de CSS, como vocÃª faria em um mixin.</li>
<li>Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando vocÃª os utiliza sem variÃ¡veis contextuais. Simplificando: o SASS vai duplicar a saÃ­da de um mixin toda vez que vocÃª o utilizÃ¡-lo, resultando nÃ£o apenas em CSS duplicado, mas tambÃ©m em uma folha de estilos maior.</li>
</ul>

<p>Considere o primeiro exemplo desse artigo:</p>

<pre class="lang-scss">@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
</pre>

<p>O CSS compilado seria esse:</p>

<pre class="lang-css">.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Observou o CSS duplicado? Ele nÃ£o Ã© tÃ£o prejudicial se forem apenas trÃªs linhas duplicadas, mas se vocÃª tiver muitos mixins que sÃ£o usados vÃ¡rias vezes em um projeto, essas trÃªs linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, sÃ³ que dessa vez utilizando o placeholder?</p>

<pre class="lang-scss">%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
</pre>

<p>Agora, esse Ã© o CSS gerado:</p>

<pre class="lang-css">.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Muito melhor! A compilaÃ§Ã£o leva vantagem <a href="http://reference.sitepoint.com/css/selectorgrouping">agrupando seletores</a>, sem nenhum estilo repetido. Assim, sempre que vocÃª quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas nÃ£o mudarÃ£o, Ã© uma boa idÃ©ia <em>estender</em> um placeholder. Isso resultarÃ¡ em um cÃ³digo CSS compilado muito mais limpo.</p>

<p>Por outro lado, se vocÃª precisa escrever as mesmas propriedades em vÃ¡rios lugares mas com valores diferentes (tamanho, cores, etc), um mixin Ã© o melhor caminho a seguir. Agora se vocÃª possui ambos, um grupo de valores fixos e outro de valores variÃ¡veis, vocÃª deve tentar usar uma combinaÃ§Ã£o dos dois.</p>

<pre class="lang-scss">%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
</pre>

<p>Neste caso, o mixin estÃ¡ <em>estendendo</em> o placeholder para os valores fixos em vez de jogÃ¡-los diretamente em seu corpo. Isso gera um CSS mais limpo:</p>

<pre class="lang-css">a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
</pre>

<h2 id="conclusÃ£o">ConclusÃ£o</h2>

<p>Ã‰ isso. Espero ter deixado claro nÃ£o sÃ³ o que sÃ£o mixins e placeholders, mas tambÃ©m quando vocÃª deve usÃ¡-los e qual os efeitos sobre o CSS compilado.</p>

<p>Se vocÃª tiver alguma coisa a acrescentar sobre suas experiÃªncias com essas <em>features</em> dos prÃ©-processadores de CSS, sinta-se livre para compartilhar nos comentÃ¡rios.</p>

<p>â€”</p>

<p>Texto traduzido e adaptado do [Se Ã© um tema que sempre vejo a respeito da utilizaÃ§Ã£o ou nÃ£o, Ã© sobre o uso de prÃ© processadores CSS. Alguns <em>devs</em> que costumo seguir e ler os artigos, e que pra mim sÃ£o algumas das nossas referÃªncias, apontam as suas consideraÃ§Ãµes sobre o tema. O Miller Medeiros, em um <a href="http://blog.millermedeiros.com/the-problem-with-css-pre-processors/">post</a> mostra alguns pontos negativos na utilizaÃ§Ã£o de prÃ© processadores. O Jean Carlos Emer em um outro <a href="http://tableless.com.br/css-steroids/" title="CSS on steroids">post</a> mostra as reais vantagens de se utilizar um prÃ©-processador. O Diego Eis, em um outro <a href="http://tableless.com.br/pre-processadores-usar-ou-nao-usar/" title="PrÃ© processadores: usar ou nÃ£o usar?">post</a> faz uma conclusÃ£o muito boa sobre a utilizaÃ§Ã£o ou nÃ£o:</p>

<blockquote>
<p>PrÃ© processadores podem ajudar como tambÃ©m podem maltratar bastante. Basta um escorregÃ£o para que seu projeto vire um inferno. &#8211; Diego Eis</p>
</blockquote>

<p>A utilizaÃ§Ã£o ou nÃ£o de um prÃ© processador fica a seu critÃ©rio mas, se vocÃª jÃ¡ utiliza nos seus projetos ou estÃ¡ pensando em usar, vocÃª sabe o que sÃ£o um <strong>placeholder</strong> e um <strong>mixin</strong>? Se sim, sabe qual a principal diferenÃ§a entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um <a href="http://www.sitepoint.com/sass-mixin-placeholder/">artigo</a> do <a href="https://twitter.com/HugoGiraudel" title="Perfil do twitter do desenvolvedor Hugo Giraudel">Hugo Giraudel</a>, um dev front-end francÃªs, no <a href="http://www.sitepoint.com/" title="Link do website SitePoint">SitePoint</a> que trata exatamente sobre esse assunto.</p>

<p>â€”</p>

<p>Quando comecei a trabalhar com SASS cerca de um ano e meio atrÃ¡s, uma coisa que me levou tempo para entender foi a diferenÃ§a entre <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins">incluir um mixin</a></em> e <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders">estender um placeholder</a></em>. Na verdade, atÃ© mesmo a noÃ§Ã£o de <em>placeholder</em> era uma espÃ©cie de magia negra vodu naquela Ã©poca.</p>

<p>Se vocÃª estiver em uma situaÃ§Ã£o semelhante, nÃ£o se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um <em>mixin</em>, e quando usar um <em>placeholder do SASS</em>. VocÃª vai entender que ambos tem diferentes finalidades e nÃ£o devem ser confundidas.</p>

<p><em>Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro prÃ©-processador CSS, seja Stylus, LESS, ou outro que vocÃª venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteÃºdo deste artigo para a ferramenta de sua escolha</em>.</p>

<p>Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos <strong>placeholder e mixins do SASS</strong>, entÃ£o vamos fazer isso jÃ¡.</p>

<h2 id="entendendo-o-mixin-1">Entendendo o mixin</h2>

<p>Um mixin Ã© uma diretiva que permite que vocÃª defina vÃ¡rias regras com diversos argumentos. Pense nisso como uma funÃ§Ã£o que irÃ¡ retornar conteÃºdo CSS ao invÃ©s de um valor. Aqui estÃ¡ a definiÃ§Ã£o de <em>mixin</em> da <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">referÃªncia do SASS</a>:</p>

<blockquote cite="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">
  <p>
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes nÃ£o semÃ¢nticas como <i>.float-left</i>. Mixins podem tambÃ©m conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem atÃ© mesmo possuÃ­rem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  </p>
</blockquote>

<p>Agora que cobrimos a terminologia, vamos dizer que vocÃª encontra algumas declaraÃ§Ãµes que sÃ£o repetidas vÃ¡rias vezes ao longo da sua folha de estilos. VocÃª que estÃ¡ familiarizado com o conceito de DRY (<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">Don&#8217;t Repeat Yourself</a>), sabe que a repetiÃ§Ã£o de cÃ³digo Ã© ruim. Para corrigir isso, vocÃª pode escrever um mixin para todas aquelas declaraÃ§Ãµes repetidas:</p>

<pre class="lang-scss">@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
</pre>

<p><em>Nota: Se vocÃª nÃ£o passar um argumento para um mixin, vocÃª pode omitir os parÃªnteses. Na verdade, vocÃª pode atÃ© omiti-los na definiÃ§Ã£o do <code>@mixin</code></em>.</p>

<p>Com este mixin recÃ©m-criado, vocÃª nÃ£o precisa repetir aquelas trÃªs linhas de cÃ³digo cada vez que precisar centralizar um elemento; vocÃª simplesmente inclui o mixin. Muito prÃ¡tico, nÃ£o Ã©?!</p>

<p>Algumas vezes vocÃª vai querer um mixin para construir o que vocÃª chamaria de <em>shorthand</em> para algumas propriedades. Por exemplo, largura e altura. VocÃª nÃ£o estÃ¡ cansado de escrever as duas linhas vÃ¡rias e vÃ¡rias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!</p>

<pre class="lang-scss">@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
</pre>

<p>Muito simples, nÃ£o Ã©? Note como deixamos o parÃ¢metro <code>$height</code> ser opcional e, por padrÃ£o assumir o mesmo valor do parÃ¢metro <code>$width</code> na assinatura do mixin. Agora, sempre que vocÃª precisar definir as dimensÃµes para um elemento, vocÃª pode simplesmente fazer isso:</p>

<pre class="lang-scss">.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
</pre>

<p><em>Nota: Um outro bom exemplo de mixin seria <a href="http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/">este aqui</a> que eu fiz para evitar de escrever as posiÃ§Ãµes <code>top</code>, <code>left</code>, <code>right</code> e <code>bottom</code> toda vez que quiser utilizar um sistema de posicionamento diferente do estÃ¡tico.</em></p>

<h2 id="conhecendo-seu-placeholder-1">Conhecendo seu Placeholder</h2>

<p>Placeholders sÃ£o um tipo de coisa estranha. Eles sÃ£o classes que nÃ£o sÃ£o retornadas quando o seu SCSS Ã© compilado. VocÃª deve entÃ£o pensar: <em>&#8220;Qual Ã© o sentido disso?&#8221;</em>. Na verdade, o ponto seria minÃ­mo senÃ£o fosse a expressÃ£o <code>@extend</code>. Mas vamos por partes. Essa Ã© a forma que vocÃª escreve um placeholder:</p>

<pre class="lang-scss">%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
</pre>

<p><em>Nota do editor: Como um placeholder, um mixin Ã© igualmente inÃºtil, a menos que seja referenciado, assim essa seÃ§Ã£o nÃ£o estÃ¡ dizendo que eles sÃ£o diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareÃ§a similar com um bloco de declaraÃ§Ã£o CSS, nÃ£o serÃ¡ gerado por conta prÃ³pria.</em></p>

<p>Basicamente vocÃª escreve exatamente como uma classe <code>CSS</code> exceto pelo sÃ­mbolo % ao invÃ©s do ponto. AlÃ©m disso, segue as mesmas <a href="http://www.w3.org/TR/html401/types.html#type-cdata">regras de nomenclatura</a> das classes.</p>

<p>Agora, se vocÃª tentar compilar seu SCSS, vocÃª nÃ£o vai ver esse pedaÃ§o de cÃ³digo no arquivo gerado. Como eu disse: <strong>placeholders nÃ£o sÃ£o compilados</strong>.</p>

<p>EntÃ£o, por agora, esse placeholder Ã© totalmente inÃºtil. VocÃª nÃ£o consegue fazer qualquer uso dele a nÃ£o ser que vocÃª veja o <code>@extend</code>. Um <code>@extend</code> tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usÃ¡-lo:</p>

<pre class="lang-scss">.container {
  @extend %center;
}
</pre>

<p>Ao fazer isso, o arquivo SASS vai pegar o conteÃºdo do placeholder <code>%center</code> e aplicÃ¡-lo no <code>.container</code> (mesmo que isso nÃ£o aconteÃ§a exatamente assim &#8211; mas isso nÃ£o Ã© importante agora). Como eu disse, vocÃª tambÃ©m pode <em>estender</em> seletores CSS jÃ¡ existentes (alÃ©m de placeholders SCSS) dessa maneira:</p>

<pre class="lang-scss">.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
</pre>

<p>Esse Ã© um caso muito comum para o uso do <code>@extend</code>. Nesse caso, pedimos para a classe <code>.table-zebra</code> se comportar exatamente como a classe <code>.table</code> e entÃ£o adicionamos as regras especÃ­ficas da classe <code>.table-zebra</code>. <em>Estender</em> seletores Ã© bastante conveniente quando vocÃª desenvolve seu site ou aplicaÃ§Ã£o em componentes modulares.</p>

<h2 id="qual-utilizar-1">Qual utilizar?</h2>

<p>EntÃ£o, a pergunta permanece: o que vocÃª deve usar? Bem, como tudo em nossa Ã¡rea: <strong>depende</strong>. Depende do contexto e, em uma outra anÃ¡lise, do que vocÃª estÃ¡ querendo fazer.</p>

<p>O melhor conselho seria: se vocÃª precisa de variÃ¡veis, utilize o mixin. Caso contrÃ¡rio, use o placeholder. HÃ¡ duas razÃµes para isso:</p>

<ul>
<li>Primeiro, vocÃª nÃ£o pode usar variÃ¡veis em um placeholder. Na verdade, atÃ© pode, mas vocÃª nÃ£o consegue <em>passar</em> uma variÃ¡vel em um placeholder para gerar um conteÃºdo especÃ­fico de CSS, como vocÃª faria em um mixin.</li>
<li>Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando vocÃª os utiliza sem variÃ¡veis contextuais. Simplificando: o SASS vai duplicar a saÃ­da de um mixin toda vez que vocÃª o utilizÃ¡-lo, resultando nÃ£o apenas em CSS duplicado, mas tambÃ©m em uma folha de estilos maior.</li>
</ul>

<p>Considere o primeiro exemplo desse artigo:</p>

<pre class="lang-scss">@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
</pre>

<p>O CSS compilado seria esse:</p>

<pre class="lang-css">.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Observou o CSS duplicado? Ele nÃ£o Ã© tÃ£o prejudicial se forem apenas trÃªs linhas duplicadas, mas se vocÃª tiver muitos mixins que sÃ£o usados vÃ¡rias vezes em um projeto, essas trÃªs linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, sÃ³ que dessa vez utilizando o placeholder?</p>

<pre class="lang-scss">%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
</pre>

<p>Agora, esse Ã© o CSS gerado:</p>

<pre class="lang-css">.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Muito melhor! A compilaÃ§Ã£o leva vantagem <a href="http://reference.sitepoint.com/css/selectorgrouping">agrupando seletores</a>, sem nenhum estilo repetido. Assim, sempre que vocÃª quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas nÃ£o mudarÃ£o, Ã© uma boa idÃ©ia <em>estender</em> um placeholder. Isso resultarÃ¡ em um cÃ³digo CSS compilado muito mais limpo.</p>

<p>Por outro lado, se vocÃª precisa escrever as mesmas propriedades em vÃ¡rios lugares mas com valores diferentes (tamanho, cores, etc), um mixin Ã© o melhor caminho a seguir. Agora se vocÃª possui ambos, um grupo de valores fixos e outro de valores variÃ¡veis, vocÃª deve tentar usar uma combinaÃ§Ã£o dos dois.</p>

<pre class="lang-scss">%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
</pre>

<p>Neste caso, o mixin estÃ¡ <em>estendendo</em> o placeholder para os valores fixos em vez de jogÃ¡-los diretamente em seu corpo. Isso gera um CSS mais limpo:</p>

<pre class="lang-css">a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
</pre>

<h2 id="conclusÃ£o-1">ConclusÃ£o</h2>

<p>Ã‰ isso. Espero ter deixado claro nÃ£o sÃ³ o que sÃ£o mixins e placeholders, mas tambÃ©m quando vocÃª deve usÃ¡-los e qual os efeitos sobre o CSS compilado.</p>

<p>Se vocÃª tiver alguma coisa a acrescentar sobre suas experiÃªncias com essas <em>features</em> dos prÃ©-processadores de CSS, sinta-se livre para compartilhar nos comentÃ¡rios.</p>

<p>â€”</p>

<p>Texto traduzido e adaptado do]<a href="http://www.sitepoint.com/sass-mixin-placeholder/">4</a> escrito pelo <a href="https://twitter.com/HugoGiraudel" title="Perfil do twitter">Hugo Giraudel</a> em 30 de janeiro de 2014.</p>

<p>TraduÃ§Ã£o autorizada pelo <a href="http://www.sitepoint.com/">SitePoint</a>.</p>

<p>Qualquer erro ou sugestÃ£o de melhoria na traduÃ§Ã£o, Ã© bem vinda! ğŸ™‚</p>

    </article>

    <div class="tb-related-posts">
      <h3>Leia mais:</h3>
      <ul>
        
        <li class="tb-related-post">
          <a href="/jhonny-roger/public/velocidade-tableless-estatico//?utm_source=tablelessRelatedLin">Performance do Tableless estÃ¡tico</a><br />
        </li>

        
        <li class="tb-related-post">
          <a href="/jhonny-roger/public/estatistica-basica-projetos-agile//?utm_source=tablelessRelatedLin">EstatÃ­stica bÃ¡sica nas entregas de projetos agileâ€Šâ€”â€ŠModa, mediana e percentil</a><br />
        </li>

        
        <li class="tb-related-post">
          <a href="/jhonny-roger/public/sketch43-novo-formato-arquivo//?utm_source=tablelessRelatedLin">O novo formato de arquivo do Sketch 43</a><br />
        </li>

        
      </ul>
    </div>

  </section>
</div>

<footer id="sd-footer">
</footer>

<script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
<script type="text/javascript" src="http://localhost/jhonny-roger/public/js/main.js?1500245850"></script>